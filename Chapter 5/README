/*fish.c*/
"struct"을 이용하여 나만의 구조화된 데이터형 만들기

<예시>
struct fish {         /*fish라는 구조화된 데이터형 만듦(int, float같은 걸 만든거임.)*/
  const name*;
  const char *species;
  int teeth;
  int age;
};


/*구조체를 선언하는 방법*/
struct fish 이름 = {똥덩어리, 똥, 0, 20};    /*데이터형(struct fish) 적기 => 변수의 이름 적기 => 순서대로 각 데이터 넣기*/

/*필드에 접근하는 방법*/
printf("이름: %s, 종: %s, 이빨: %i, 나이: %i", 이름.name, 이름.species, 이름.teeth, 이름.age);   //점연산자와 변수이름 사용




**turtle.c**
함수의 인자로서 구조체를 전달.
원래 구조체의 값만 복사됨.
함수 안에서의 복사된 구조체에 작용하는 변화 => 원래 구조체에 영향을 미치지  않음.


**happy_birthday_turtle_work.c**
위의 문제를 해결하기 위해 함수의 인자로 구조체 포인터를 사용.


**safe.c**
"구조체 안의 구조체" 안의 필드를 호출할 때 "->" 표기법 이용.
ex) a->age의 의미 : a가 가르키는 구조체의 age필드.  //a는 구조체의 주가 저장되어있음.


**fruit_weight.c**
주로 공용체에 대해 배움.
구조체 안에 공용체 사용 가능.
"->"표기법 이용하여 필드값 접근 가능.
두개의 변수가 같은 데이터형일 경우, 둘 중 하나의 변수에 값을 대입 ==> 두 변수 모두에 저장(?)되는 듯.
