/*fish.c*/
"struct"을 이용하여 나만의 구조화된 데이터형 만들기

<예시>
struct fish {         /*fish라는 구조화된 데이터형 만듦(int, float같은 걸 만든거임.)*/
  const name*;
  const char *species;
  int teeth;
  int age;
};

/*구조체를 선언하는 방법*/
struct fish 이름 = {똥덩어리, 똥, 0, 20};    /*데이터형(struct fish) 적기 => 변수의 이름 적기 => 순서대로 각 데이터 넣기*/

/*필드에 접근하는 방법*/
printf("이름: %s, 종: %s, 이빨: %i, 나이: %i", 이름.name, 이름.species, 이름.teeth, 이름.age);   //점연산자와 변수이름 사용
!!여러 값을 한꺼번에 저장하고 싶을 때!!



**turtle.c**
함수의 인자로서 구조체를 전달.
원래 구조체의 값만 복사됨.
함수 안에서의 복사된 구조체에 작용하는 변화 => 원래 구조체에 영향을 미치지  않음.


**happy_birthday_turtle_work.c**
위의 문제를 해결하기 위해 함수의 인자로 구조체 포인터를 사용.


**safe.c**
"구조체 안의 구조체" 안의 필드를 호출할 때 "->" 표기법 이용.
ex) a->age의 의미 : a가 가르키는 구조체의 age필드.  //a는 구조체의 주가 저장되어있음.


**fruit_weight.c**    //2021.03.08
주로 공용체에 대해 배움.    //공용체는 동적 메모리랑 다른 듯..? 
구조체 안에 공용체 사용 가능.
"->"표기법 이용하여 필드값 접근 가능.
두개의 변수가 같은 데이터형일 경우, 둘 중 하나의 변수에 값을 대입 ==> 두 변수 모두에 저장(?)되는 듯.
p296. 한 필드로 장하고 다른 필드를 사용해 읽을 수도 있음. but 때로는 큰 문제가 발생할 수도 있음.(쓰레기값이 오거나 0이 나오는 듯)
!!여러 값 중에 하나만 저장하고 싶을 때!!



**enumtest.c**      //2021.03.08(17:08)
열거형에 대해 배움. //열거형을 이용해 공용체에 저장한 값을 알아보는 프로그램.
열거형과 구조체의 차이: 필드(?)의 구분을 ","(콤마)로 함.    //구조체는 ";"(세미콜론)으로 함.
열거형과 구조체의 공통점: 별명을 붙일 수 있음. //typedef enum { ... } unit_of_measure;   //unit_of_measure이 별명임.
구조체 안에 열거형 사용 가능.

